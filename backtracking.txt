

##### BACKTRACKING #####
Encontrar todas las soluciones posibles.

void backtraking (d: dades, s: solucion)
{
    if (esSolucionFinal(s)) tratarSolucion;
    else {
        while (hayaDecisionesPorTomar) {
            decision(d) = cogerDecision();
            if (esFactible(d)) {    // Podar arbre si no es factible una solucio continuant
                marcar(d);
                backtracking(d, s^{d});
                desmarcar(d);
            }
        }
    }
}

#include <iostream>
#include <vector>
using namespace std;

void printVec(const vector<int> &v)
{
    if (v.size() != 0) cout << "(" << v[0];
    for (unsigned int i = 1; i < v.size(); ++i) cout << "," << v[i];
    if (v.size() != 0) cout << ")" << endl;
}

void ena(int k, int n, vector<bool> &visto, vector<int> &sol)
{
    if(k == n) printVec(sol);
    else {
        for(int i = 0; i < n; ++i) {
            if (not visto[i]) {
                visto[i] = true;
                sol[k] = i+1;
                ena(k+1, n, visto, sol);
                visto[i] = false;
            }
        }
    }
}

int main()
{
    int n;
    cin >> n;
    vector<bool> visto(n);
    vector<int> sol(n);
    ena(0, n, visto, sol);
}